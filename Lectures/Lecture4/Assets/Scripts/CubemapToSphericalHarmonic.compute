// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ComputeHarmonics

#define PI            3.14159265359f
#define TWO_PI        6.28318530718f
#define FOUR_PI       12.56637061436f
#define INV_PI        0.31830988618f
#define INV_TWO_PI    0.15915494309f
#define INV_FOUR_PI   0.07957747155f
#define HALF_PI       1.57079632679f
#define INV_HALF_PI   0.636619772367f

RWStructuredBuffer<float4> SH_0_1_r;
RWStructuredBuffer<float4> SH_0_1_g;
RWStructuredBuffer<float4> SH_0_1_b;

RWStructuredBuffer<float4> SH_2_r;
RWStructuredBuffer<float4> SH_2_g;
RWStructuredBuffer<float4> SH_2_b;

RWStructuredBuffer<float4> SH_2_rgb;

Texture2D<half4> _Env;
SamplerState samplerLinearRepeat;

static const float2 invPi = float2(0.5 * INV_PI, INV_PI);
float2 UnitSphereVectorToUV(float3 direction)
{
    float2 uv = float2(atan2(direction.z, direction.x), asin(direction.y));
    uv *= invPi;
    uv += 0.5;

    return uv;
}

float3 SampleColor(float3 direction)
{   
    float2 uv = UnitSphereVectorToUV(normalize(direction));
    return _Env.SampleLevel(samplerLinearRepeat, float4(uv, 0, 0), 0);
}

uint Hash(uint s)
{
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return s;
}

float ToRandomFloat(uint randomInt)
{
    return float(randomInt) / 4294967295.0; // 2^32-1
}

float3 RandomUnitSphereVector(in out uint seed)
{
    uint hash1 = Hash(seed);
    uint hash2 = Hash(hash1);
    seed = hash2;

    float rand1 = 2 * ToRandomFloat(hash1) - 1;
    float rand2 = 2 * PI * ToRandomFloat(hash2);

    float y = rand1;
    float smallRadius = sqrt(1 - y * y);

    return float3(smallRadius * cos(rand2), y, smallRadius * sin(rand2));
}

[numthreads(1024, 1, 1)]
void ComputeHarmonics(uint id : SV_DispatchThreadID)
{
    const int THREADS = 1024;
    const int SAMPLES = 10;
    
    // See SH.shader for more details
    float4 results[7] = {
        float4(0, 0, 0, 0), // SH_0_1_r
        float4(0, 0, 0, 0), // SH_0_1_g
        float4(0, 0, 0, 0), // SH_0_1_b
        
        float4(0, 0, 0, 0), // SH_2_r
        float4(0, 0, 0, 0), // SH_2_g
        float4(0, 0, 0, 0), // SH_2_b
        
        float4(0, 0, 0, 0), // SH_2_rgb
    };
    
    // TASK: project light from _Env to spherical harmonic coefficients;
    // Multiply that by the same polynom coeffients, because they appear in the projection of max(0, cos(theta)) 
    // and store them in results[]
    
    uint seed = id;
    for (int sample = 0; sample < SAMPLES; ++sample)
    {
        float3 direction = RandomUnitSphereVector(seed);
        float3 L = SampleColor(direction);
        
        // all the coefficients are harmonic coeffeceint (HC) from projection
        // times HC from subsequent multiplication by spherical harmonic
        // times 4PI as sphere surface area for Monte-Carlo
        // times 1 / PI for diffuse brdf
        
        float zeroOrderCoeff = INV_PI;
        float3 firstOrderCoeff = direction * 3 * INV_PI;
        float3 secondOrderCoeff1 = (direction.xyz * direction.yzx) * 15 * INV_PI;
        float secondOrderCoeff2 = (3 * direction.z * direction.z - 1) * 5 * INV_PI * 0.25;
        float secondOrderCoeff3 = (direction.x * direction.x - direction.y * direction.y) * 15 * INV_PI * 0.25;
        
        results[0].w += L.r * zeroOrderCoeff;
        results[1].w += L.g * zeroOrderCoeff;
        results[2].w += L.b * zeroOrderCoeff;
        
        results[0].xyz += L.rrr * firstOrderCoeff;
        results[1].xyz += L.ggg * firstOrderCoeff;
        results[2].xyz += L.bbb * firstOrderCoeff;
        
        results[3].xyz += L.rrr * secondOrderCoeff1;
        results[4].xyz += L.ggg * secondOrderCoeff1;
        results[5].xyz += L.bbb * secondOrderCoeff1;
        
        results[3].w += L.r * secondOrderCoeff2;
        results[4].w += L.g * secondOrderCoeff2;
        results[5].w += L.b * secondOrderCoeff2;
        
        results[6].x += L.r * secondOrderCoeff3;
        results[6].y += L.g * secondOrderCoeff3;
        results[6].z += L.b * secondOrderCoeff3;
    }
    
    for (int c = 0; c < 7; c++)
    {
        results[c] /= SAMPLES;
    }
    
    for (int c = 0; c < 3; c++)
    {
        // Precomputing coefficients of max(0, cos(theta) for L=0
        results[c].w *= PI; 
        // Precomputing coefficients of max(0, cos(theta) for L=1
        results[c].xyz *= PI * 2 / 3;
    }
    
    for (c = 0; c < 4; c++)
    {
        // Precomputing coefficients of max(0, cos(theta) for L=2
        results[3 + c] *= PI / 4;
    } 
    
    SH_0_1_r[id] = results[0];
    SH_0_1_g[id] = results[1];
    SH_0_1_b[id] = results[2];
    
    SH_2_r[id] = results[3];
    SH_2_g[id] = results[4];
    SH_2_b[id] = results[5];    
    
    SH_2_rgb[id] = results[6];
}
